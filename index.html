<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>United States COVID-19 Spread Dashboard</title>
    <meta
      name="description"
      content="Dashboard of COVID-19 spread in USA using Data from The New York Times"
    />
    <meta name="author" content="David Schnurr" />
    <meta name="Robots" content="INDEX,FOLLOW" />

    <script src="https://unpkg.com/d3@5.15.0/dist/d3.min.js"></script>
    <script src="https://unpkg.com/jquery@3.4.1/dist/jquery.js"></script>
    <script src="https://unpkg.com/moment@2.24.0/moment.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat:400,700&display=swap"
      rel="stylesheet"
    />
    <link href="style.css" rel="stylesheet" />
  </head>
  <body>
    <div>
      <header>
        <div class="flex-row flex-center">
          <div>
            <h1>United States COVID-19 Spread</h1>
            <h3>
              Data from The New York Times. Updates automatically with their
              <a href="https://github.com/nytimes/covid-19-data">data on Github</a>. See their
              tracker
              <a href="https://www.nytimes.com/interactive/2020/us/coronavirus-us-cases.html"
                >here</a
              >.
            </h3>
            <h4>
              Built by <a href="https://twitter.com/dschnr" target="_blank">@dschnr</a>. Source
              available <a href="https://github.com/schnerd/us-covid-dashboard">on Github</a>.
            </h4>
          </div>
        </div>
        <div class="flex-row flex-center flex-wrap">
          <div class="filter-item">
            <select id="state-select" class="select-css">
              <option value="allStates" selected>All States</option>
            </select>
          </div>
          <div class="filter-item">
            <select id="field-select" class="select-css">
              <option value="newCases" selected>Daily New Cases</option>
              <option value="newDeaths">Daily New Deaths</option>
              <option value="cases">Confirmed Cases</option>
              <option value="deaths">Confirmed Deaths</option>
            </select>
          </div>
          <div class="filter-item">
            <select id="time-select" class="select-css">
              <option value="last7Days" selected>Last 7 days</option>
              <option value="last14Days" selected>Last 14 days</option>
              <option value="lastMonth">Last Month</option>
              <option value="all">All</option>
            </select>
          </div>
          <div class="filter-item">
            <label class="cb-container">
              <input type="checkbox" class="cb-input" id="cb-use-log-scale" />
              <span class="cb-mark"></span>
              <span class="cb-label">Log Scale</span>
            </label>
          </div>
          <div class="filter-item">
            <label class="cb-container">
              <input type="checkbox" class="cb-input" id="cb-consistent-y" checked />
              <span class="cb-mark"></span>
              <span class="cb-label">Consistent Y-Axis</span>
            </label>
          </div>
        </div>
      </header>
      <div role="button" class="back-to-states">← Back to states</div>

      <div id="viz">
        <svg id="svg"></svg>
        <div id="tooltip"></div>
      </div>
    </div>

    <script>
      const isTouchDevice = 'ontouchstart' in document.documentElement;
      if (isTouchDevice) {
        $(document.body).addClass('touch');
      }

      let useLog = false;
      let stateData = null;
      let countyData = null;
      let curData = null;
      let field = 'newCases';
      let timeFilter = 'last14Days';
      let consistentY = true;
      let tooltipValue = null;
      let tooltipShown = null;

      const dataPointLabels = {
        cases: 'Total Cases',
        deaths: 'Total Deaths',
        newCases: 'New Cases',
        newDeaths: 'New Deaths',
      };

      function processStates(csv) {
        const nestedStates = d3
          .nest()
          .key(k => k.state)
          .entries(csv);

        const [states, extents] = processGroups(nestedStates);
        return {
          states,
          extents,
        };
      }

      function processCounties(csv) {
        // First nest counties by state
        const nestedStates = d3
          .nest()
          .key(k => k.state)
          .entries(csv);

        const stateMap = {};

        nestedStates.forEach(state => {
          const counties = d3
            .nest()
            .key(k => k.county)
            .entries(state.values);
          const [byCounty, extents] = processGroups(counties);
          state.counties = byCounty;
          state.extents = extents;
          stateMap[state.key] = {key: state.key, counties, extents};
        });

        return stateMap;
      }

      function processGroups(groups) {
        const extents = {
          date: [null, null],
          cases: [null, null],
          deaths: [null, null],
          newCases: [null, null],
          newDeaths: [null, null],
        };

        const keys = ['date', 'cases', 'deaths', 'newCases', 'newDeaths'];

        groups.forEach(group => {
          const newValues = [];
          for (let i = 0; i < group.values.length; i++) {
            const prevRow = group.values[i - 1];
            const row = group.values[i];
            const [year, month, date] = row.date.split('-');
            const parsed = {
              ...row,
              date: new Date(Number(year), Number(month) - 1, Number(date)),
              cases: Number(row.cases),
              deaths: Number(row.deaths),
            };
            if (prevRow) {
              parsed.newCases = parsed.cases - prevRow.cases;
              parsed.newDeaths = parsed.deaths - prevRow.deaths;
            } else {
              parsed.newCases = parsed.cases;
              parsed.newDeaths = parsed.deaths;
            }
            newValues.push(parsed);

            keys.forEach(key => {
              if (extents[key][0] === null || parsed[key] < extents[key][0]) {
                extents[key][0] = parsed[key];
              }
              if (extents[key][1] === null || parsed[key] > extents[key][1]) {
                extents[key][1] = parsed[key];
              }
            });
          }
          group.values = newValues;
        });

        return [groups, extents];
      }

      function last(arr) {
        return arr[arr.length - 1];
      }

      function render(data) {
        const {extents, isCounties} = data;

        const groups = data.groups.slice(0);
        groups.sort((a, b) => {
          return last(b.values)[field] - last(a.values)[field];
        });

        const yScaleType = useLog ? 'scaleLog' : 'scaleLinear';

        const firstDate = extents.date[0];
        const lastDate = extents.date[1];

        let daysToShow;
        if (timeFilter === 'last7Days') {
          daysToShow = 7;
        } else if (timeFilter === 'last14Days') {
          daysToShow = 14;
        } else if (timeFilter === 'lastMonth') {
          daysToShow = 30;
        } else {
          daysToShow = moment(lastDate).diff(moment(firstDate), 'days');
        }
        const datesToShow = [lastDate];
        for (let i = 1; i < daysToShow; i++) {
          const nextDate = new Date(lastDate);
          nextDate.setDate(lastDate.getDate() - i);
          datesToShow.unshift(nextDate);
        }

        const useLarge = window.innerWidth >= 1024;
        const chartAspectRatio = 2.15;
        const chartPadding = useLarge ? 30 : 25;
        const estChartWidth = useLarge ? 250 : 150;
        const numCols = Math.floor(window.innerWidth / (estChartWidth + chartPadding));
        const chartWidth = Math.floor((window.innerWidth - chartPadding * (numCols + 1)) / numCols);

        const numStates = groups.length;
        const chartHeight = Math.floor(chartWidth / chartAspectRatio);
        const yAxisWidth = useLarge ? 40 : 30;
        const xAxisHeight = useLarge ? 20 : 14;
        const winWidth = window.innerWidth;
        const barPad = daysToShow > 10 ? 1 : 2;

        const colWidth = chartWidth + chartPadding;
        const rowHeight = chartHeight + xAxisHeight + chartPadding;

        const numRows = Math.ceil(numStates / numCols);

        const totalHeight = numRows * rowHeight;

        const xScale = d3
          .scaleBand()
          .domain(d3.range(daysToShow))
          .rangeRound([0, chartWidth])
          .paddingInner((barPad * daysToShow) / chartWidth)
          .paddingOuter((barPad * 5) / chartWidth);
        const barWidth = xScale.bandwidth();

        const barXMidpoints = datesToShow.map((d, i) => {
          return xScale(i) + barWidth / 2;
        });

        function makeYScale(extent) {
          const domain = [Math.max(extent[0], 0), Math.max(extent[1], 10)];
          if (useLog && domain[0] === 0) {
            domain[0] = 1;
          }
          return d3[yScaleType]()
            .domain(domain)
            .range([chartHeight, 0]);
        }

        function makeAxis(scale) {
          const domainMax = scale.domain()[1];
          return d3
            .axisLeft(scale)
            .ticks(
              !useLog ? 4 : domainMax < 100 ? 1 : domainMax < 1000 ? 2 : domainMax < 10000 ? 3 : 4,
            )
            .tickSizeInner(-chartWidth)
            .tickSizeOuter(0)
            .tickFormat(d => {
              return formatYTick(d);
            });
        }
        const yScale = makeYScale(extents[field]);
        const yAxis = makeAxis(yScale);

        const $viz = d3.select('#viz');
        const $svg = d3.select('#svg');

        $svg.attr('class', consistentY ? 'consistent-y' : '');

        // Make sure we're starting fresh
        $svg.selectAll('*').remove();

        // Create grid of rows and columns
        const $rows = $svg
          .attr('viewBox', [0, 0, winWidth, totalHeight])
          .selectAll('g.row')
          .data(d3.range(numRows))
          .enter()
          .append('g')
          .attr('class', 'row')
          .attr('transform', row => `translate(${yAxisWidth}, ${row * rowHeight})`);

        // Add cells
        $rows.each(function(row) {
          const lastItemNumber = (row + 1) * numCols;
          const numColsForRow = lastItemNumber > groups.length ? groups.length % numCols : numCols;
          const range = d3.range(numColsForRow).map(i => ({row, col: i}));
          d3.select(this)
            .selectAll('g.cell')
            .data(range)
            .enter()
            .append('g')
            .attr('class', 'cell')
            .attr('transform', d => `translate(${d.col * colWidth}, 0)`);
        });

        const $cells = $svg.selectAll('g.cell');

        // Fill each cell with a chart
        $cells.each(function(d, index) {
          const $cell = d3.select(this);
          const data = groups[index];
          if (!data) {
            return;
          }
          const values = data.values;
          const totalCases = last(values).cases;

          // Add baseline
          $cell
            .append('line')
            .attr('class', 'baseline')
            .attr('y1', chartHeight)
            .attr('y2', chartHeight)
            .attr('x2', chartWidth);

          // Add axis
          let cellYScale = yScale;
          let cellYAxis = yAxis;
          if (!consistentY) {
            const extent = d3.extent(values, d => d[field]);
            cellYScale = makeYScale(extent);
            cellYAxis = makeAxis(cellYScale);
          }

          $cell
            .append('g')
            .attr('transform', 'translate(0,0)')
            .call(cellYAxis);

          // Make sure we show all dates in proper locations (even if group has data missing at that date)
          const shownValues = [];
          let valuesIndex = 0;
          for (var i = 0; i < datesToShow.length; i++) {
            while (
              values[valuesIndex] &&
              values[valuesIndex].date.getTime() < datesToShow[i].getTime()
            ) {
              valuesIndex++;
            }
            if (values[valuesIndex].date.getTime() === datesToShow[i].getTime()) {
              shownValues.push({...values[valuesIndex], i});
            }
          }

          $cell
            .selectAll('.bar')
            .data(shownValues)
            .enter()
            .append('rect')
            .attr('class', 'bar')
            .attr('width', barWidth)
            .attr('x', d => xScale(d.i))
            .attr('y', d => {
              let y = cellYScale(d[field]);
              if (Number.isNaN(y)) {
                y = chartHeight;
              }
              return Math.floor(y);
            })
            .attr('height', d => {
              let y = cellYScale(d[field]);
              if (Number.isNaN(y)) {
                return 0;
              }
              return Math.max(Math.ceil(chartHeight - y), 0);
            });

          const $crosshair = $cell
            .append('line')
            .attr('y1', 0)
            .attr('y2', chartHeight)
            .attr('class', 'crosshair crosshair-hidden');

          function onMouseMove() {
            const evt = d3.event;
            const mouse = d3.mouse(this);
            const xPos = mouse[0];
            const bisectIndex = d3.bisectLeft(barXMidpoints, xPos);
            const left = barXMidpoints[bisectIndex - 1];
            const right = barXMidpoints[bisectIndex];
            const index =
              left == undefined || Math.abs(xPos - right) < Math.abs(xPos - left)
                ? bisectIndex
                : bisectIndex - 1;
            const date = datesToShow[index];
            const value = shownValues.find(v => v.date.getTime() === date.getTime());
            if (value && (value !== tooltipValue || !tooltipShown)) {
              const chPos = Math.round(xScale(index) + barWidth / 2);
              $crosshair
                .attr('x1', chPos)
                .attr('x2', chPos)
                .classed('crosshair-hidden', false);
              showTooltip(value, mouse, evt);
            }
          }

          function onClick() {
            if (!isCounties) {
              renderCounties(data.key);
              $('#state-select').val(data.key);
            }
          }

          const $hover = $cell
            .append('rect')
            .attr('class', 'pointer')
            .attr('width', chartWidth)
            .attr('height', chartHeight);

          // Touch device events are slightly different
          if (isTouchDevice) {
            $hover.on('click', () => {
              // Dont let this bubble up to document click
              d3.selectAll('.crosshair').classed('crosshair-hidden', true);
              d3.event.stopPropagation();
              onMouseMove.call(this);
            });
          } else {
            $hover
              .on('mousemove', onMouseMove)
              .on('click', onClick)
              .on('mouseout', function() {
                $crosshair.classed('crosshair-hidden', true);
                hideTooltip();
              });
          }

          // Add label above other elements to make it clickable
          $cell
            .append('text')
            .text(data.key)
            .attr('x', 6)
            .attr('y', 14)
            .attr('class', 'cell-label')
            .on('click', onClick);
        });

        // Add start dates
        const endDate = last(groups[0].values).date;
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - daysToShow + 1);

        $cells
          .append('text')
          .attr('class', 'x-tick x-tick-start')
          .attr('text-anchor', 'start')
          .attr('x', 0)
          .attr('y', chartHeight + 4)
          .text(formatXDate(startDate));

        $cells
          .append('text')
          .attr('class', 'x-tick x-tick-end')
          .attr('text-anchor', 'end')
          .attr('x', chartWidth)
          .attr('y', chartHeight + 4)
          .text(formatXDate(endDate));
      }

      function showTooltip(value, mouse, evt) {
        tooltipValue = value;
        tooltipShown = true;
        const {offsetX, offsetY} = evt;
        const pad = 10;
        const css = {left: '', right: '', top: `${offsetY + pad}px`, bottom: ''};
        const winWidth = window.innerWidth;
        // If it overflows right
        if (offsetX + 150 > winWidth) {
          css.right = `${winWidth - offsetX + pad}px`;
        } else {
          css.left = `${offsetX + pad}px`;
        }

        const dataPoints = ['cases', 'deaths', 'newCases', 'newDeaths'];
        const dataPointEl = dataPoints.map((k, i) => {
          return `
					<div class="tooltip-dp flex-row flex-center ${k === field ? 'tooltip-dp-active' : ''}">
						<div class="tooltip-dp-label">${dataPointLabels[k]}</div>
						<div class="tooltip-dp-val">${formatTooltipValue(value[k])}</div>
					</div>
						`;
        });

        const drilldownMsg = !value.county
          ? '<div class="tooltip-drill"><span class="click">Click</span><span class="tap">Tap</span><span> to see counties</span></div>'
          : '';

        $('#tooltip')
          .addClass('shown')
          .css(css)
          .html(
            `<div><h4>${formatTooltipDate(value.date)}</h4>${dataPointEl.join(
              '',
            )}${drilldownMsg}</div>`,
          );
      }

      function hideTooltip() {
        $('#tooltip').removeClass('shown');
        tooltipShown = false;
      }

      function formatXDate(d) {
        return d.toLocaleString('default', {month: 'short', day: 'numeric'});
      }

      function formatTooltipDate(d) {
        return d.toLocaleString('default', {year: 'numeric', month: 'long', day: 'numeric'});
      }

      function formatYTick(n) {
        if (n >= 1e6) {
          return `${Math.round(n / 1e6)}m`;
        }
        if (n >= 1e3) {
          return `${Math.round(n / 1e3)}k`;
        }
        return n;
      }

      const tooltipFmt = d3.format(',d');
      function formatTooltipValue(n) {
        return tooltipFmt(n);
      }

      function attachEvents() {
        $('#state-select').change(function() {
          const val = $(this).val();
          window.scrollTo(0, 0);
          if (val === 'allStates') {
            renderAllStates();
          } else {
            renderCounties(val);
          }
        });
        $('.back-to-states').click(function() {
          $('#state-select').val('allStates');
          window.scrollTo(0, 0);
          renderAllStates();
        });
        $('#field-select').change(function() {
          field = $(this).val();
          if (curData) {
            render(curData);
          }
        });
        $('#time-select').change(function() {
          timeFilter = $(this).val();
          if (curData) {
            render(curData);
          }
        });
        $('#tooltip').click(function() {
          if (tooltipValue && !tooltipValue.county) {
            renderCounties(tooltipValue.state);
            $('#state-select').val(tooltipValue.state);
          }
        });
        $('#cb-use-log-scale').change(function() {
          useLog = $(this).is(':checked');
          if (curData) {
            render(curData);
          }
        });
        $('#cb-consistent-y').change(function() {
          consistentY = $(this).is(':checked');
          if (curData) {
            render(curData);
          }
        });
        $(document).on('click', function(evt) {
          hideTooltip();
        });
      }

      function renderAllStates() {
        curData = {groups: stateData.states, extents: stateData.extents};
        render(curData);
        $('.back-to-states').removeClass('shown');
        hideTooltip();
      }
      function renderCounties(state) {
        const stateData = countyData[state];
        curData = {groups: stateData.counties, extents: stateData.extents, isCounties: true};
        render(curData);
        $('.back-to-states').addClass('shown');
        hideTooltip();
      }

      const resizeWindow = _.throttle(() => {
        if (curData) {
          render(curData);
        }
      }, 100);
      window.addEventListener('resize', resizeWindow);

      d3.csv('https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv').then(
        csv => {
          stateData = processStates(csv);
          const stateOptions = stateData.states
            .sort((a, b) => a.key.localeCompare(b.key))
            .map(s => `<option value="${s.key}">${s.key}</option>`)
            .join('');
          $('#state-select').html(
            `<option value="allStates" selected>All States</option>${stateOptions}`,
          );
          renderAllStates();
        },
      );

      // Delay this slightly – not needed until drill-down
      setTimeout(() => {
        d3.csv(
          'https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv',
        ).then(csv => {
          countyData = processCounties(csv);
        });
      }, 200);

      attachEvents();
    </script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-162036100-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-162036100-1');
    </script>
  </body>
</html>
